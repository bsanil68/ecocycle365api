
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IOTDeviceData {
    struct Record {
        string ipfsHash;
        uint256 timestamp;
        string deviceId;
    }

    mapping(uint256 => Record) public records;
    uint256 public recordCount;

    event HashStored(uint256 indexed recordId, string ipfsHash, uint256 timestamp, string deviceId);

    // Store a new hash with deviceId
    function storeHash(string memory _ipfsHash, string memory _deviceId) public {
        records[recordCount] = Record(_ipfsHash, block.timestamp, _deviceId);
        emit HashStored(recordCount, _ipfsHash, block.timestamp, _deviceId);
        recordCount++;
    }

    // Retrieve all hashes for a specific deviceId
    function getHashesByDeviceId(string memory _deviceId) public view returns (string[] memory, uint256[] memory) {
        uint256 count = 0;

        // First, count how many records match the deviceId
        for (uint256 i = 0; i < recordCount; i++) {
            if (keccak256(abi.encodePacked(records[i].deviceId)) == keccak256(abi.encodePacked(_deviceId))) {
                count++;
            }
        }

        // Prepare arrays to store results
        string[] memory ipfsHashes = new string[](count);
        uint256[] memory timestamps = new uint256[](count);

        uint256 index = 0;

        // Collect records matching the deviceId
        for (uint256 i = 0; i < recordCount; i++) {
            if (keccak256(abi.encodePacked(records[i].deviceId)) == keccak256(abi.encodePacked(_deviceId))) {
                ipfsHashes[index] = records[i].ipfsHash;
                timestamps[index] = records[i].timestamp;
                index++;
            }
        }

        return (ipfsHashes, timestamps);
    }
}
